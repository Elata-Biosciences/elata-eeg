# EEG Applet Architecture: Synthesized Plan

This document outlines the refined architecture for the EEG "Applets" system, incorporating feedback for a modular, extensible, and developer-friendly approach. The core idea is to use selective compilation of DSP modules based on Cargo features, automated by a build script.

## 1. Core Architectural Principles

*   **Modularity:** DSP functionalities are encapsulated in separate Rust crates. Applet UIs are distinct components.
*   **Selective Compilation:** Only DSP modules actively used by installed applets are compiled into the main daemon, reducing build times and binary size.
*   **Automation:** A build script (`scripts/build_dsp.py`) handles the integration of DSP modules based on applet manifests.
*   **Developer Experience:** Streamlined processes for creating, installing, and managing applets, including CLI tooling and clear dependency management.

## 2. Key Components and Structure

### A. Project Structure (Conceptual)

```
/
├── Cargo.toml                # Workspace root (includes daemon and all DSP crates)
├── daemon/                   # Main backend service (Rust)
│   ├── src/
│   │   ├── applets/mod.rs    # Auto-generated by build_dsp.py
│   │   └── main.rs
│   └── Cargo.toml            # Defines features for each DSP crate
├── dsp/                      # Directory for all individual DSP Rust crates
│   ├── fft_spectrum/         # Example DSP crate
│   │   ├── src/lib.rs
│   │   └── Cargo.toml
│   └── band_power/           # Another example DSP crate
│       ├── src/lib.rs
│       └── Cargo.toml
├── applets/                  # Directory for all installed applets
│   ├── my_fft_applet/
│   │   ├── manifest.json     # { ..., "dsp": "fft_spectrum", "dspDeps": {"python": "requirements.txt"} }
│   │   ├── ui/               # React UI components
│   │   ├── dsp/              # Python DSP scripts, models
│   │   │   └── requirements.txt
│   │   └── README.md
│   └── another_applet/
│       └── manifest.json     # { ..., "dsp": "band_power" }
├── kiosk/                    # React frontend application
└── scripts/
    └── build_dsp.py          # Python script for build automation
    └── eeg-applet-cli        # CLI tool for applet scaffolding
```

### B. `manifest.json` (Applet Definition)

Key fields relevant to this architecture:

```json
{
  "id": "unique-applet-id",
  "version": "1.0.0",
  "name": "FFT Spectrum Visualizer",
  "description": "Displays a real-time FFT spectrum.",
  // ... other fields like icon, UI entry points ...
  "dsp": "fft_spectrum", // or ["fft_spectrum", "another_dsp_if_needed"]
  "dspWebSocketPath": "/applet/fft_spectrum/data", // Example
  "dspDeps": {
    "python": "dsp/requirements.txt" // Path to Python dependencies, if any
    // "rust": {} // Rust deps handled by the DSP crate itself
  },
  "requiredKioskApiVersion": "1.0.0" // For kioskApi.v1
}
```

### C. `daemon/Cargo.toml` (Relevant Sections)

```toml
[workspace]
members = [
  ".", # if daemon is the workspace root, or list daemon and dsp/* crates
  "../dsp/fft_spectrum",
  "../dsp/band_power",
  # ... other dsp crates
]

[features]
default = []
# Features will be dynamically populated or referenced from an included file
# generated by build_dsp.py, e.g.:
fft_spectrum = []
band_power = []
# For actual dependencies:
# fft_spectrum = ["elata_dsp_fft_spectrum"] # if using path dependencies
# elata_dsp_fft_spectrum = { path = "../dsp/fft_spectrum" } # if daemon is not workspace root
```

### D. `daemon/src/applets/mod.rs` (Auto-Generated)

```rust
// This file is auto-generated by scripts/build_dsp.py

#[cfg(feature = "fft_spectrum")]
pub mod fft_spectrum {
    // Potentially use elata_dsp_fft_spectrum::* or similar
    // This part needs refinement based on how DSP crates expose their functionality
    // For example, if each DSP crate has a known entry point function or struct.
}

#[cfg(feature = "band_power")]
pub mod band_power {
    // pub use elata_dsp_band_power::*;
}

// ... other DSP modules based on active features
```
The exact content here will depend on how the daemon instantiates and calls the DSP logic from the compiled crates.

### E. `scripts/build_dsp.py` (Build Automation Script)

*   **Responsibilities:**
    1.  Scans all `applets/*/manifest.json` files to identify unique `dsp` modules required.
    2.  Generates/updates `daemon/src/applets/mod.rs` with `#[cfg(feature = "dsp_name")] pub mod dsp_name;` (or `use dsp_crate_name::*;`) for each required DSP.
    3.  Generates a list of Cargo features to be enabled for the `cargo build` command. This could be:
        *   A simple space-separated string of feature names.
        *   A snippet for a `Cargo.feature.toml` file that `daemon/Cargo.toml` can include (preferred for CI).
    4.  (Future) Potentially trigger `pip install` for Python dependencies specified in `dspDeps`.

## 3. Build and Compilation Flow

1.  Developer creates/installs an applet, specifying a DSP module in its `manifest.json`.
2.  Before building the daemon, `scripts/build_dsp.py` is run.
3.  The script updates `daemon/src/applets/mod.rs` and generates the necessary feature flags/config.
4.  `cargo build` (for the daemon) is executed with these features.
5.  Only the specified DSP crates (and their dependencies) are compiled into the daemon binary.

**Visualizing the Build Process:**

```mermaid
graph TD
    subgraph AppletDevelopment
        Dev[Applet Developer] -- Modifies/Creates --> Manifest(applets/*/manifest.json);
        Manifest -- Specifies DSP needed, e.g. --> DSPNeeded{{dsp: "cool_fft"}};
    end

    subgraph BuildAutomationScript
        BuildScript[scripts/build_dsp.py] -- Scans all --> Manifest;
        BuildScript -- Generates --> ModRs(daemon/src/applets/mod.rs <br> `#[cfg(feature = "cool_fft")] pub mod cool_fft;`);
        BuildScript -- Generates --> FeaturesToml(Cargo feature flags/toml snippet <br> `features = ["cool_fft", ... ]`);
    end

    subgraph DaemonCompilation
        DaemonCargo[daemon/Cargo.toml] -- Defines & Includes --> FeaturesToml;
        Cargo[Cargo Build Process] -- Uses --> ModRs;
        Cargo -- Reads features from --> DaemonCargo;
        Cargo -- Conditionally compiles --> DSPCrate("dsp/cool_fft_crate");
        DSPCrate --> DaemonBin(Compiled Daemon Binary);
    end

    AppletDevelopment --> BuildAutomationScript;
    BuildAutomationScript --> DaemonCompilation;
```

## 4. Key Enhancements Incorporated

*   **IPC Contract:** Clearly defined JSON schemas for messages and WebSocket topic structures are needed for stable communication between Kiosk UI, Applet UI, Daemon, and DSP runners. (To be detailed in a separate document or section).
*   **Dependency Management (`dspDeps`):**
    *   Applet `manifest.json` can specify Python dependencies via a `requirements.txt` file.
    *   The build/installation process for an applet should handle `pip install -r requirements.txt` into an isolated environment (e.g., using `pipx` or a dedicated venv per applet).
*   **Security:**
    *   Implement checksum validation for downloaded applet code.
    *   Consider basic signature verification for applets from trusted sources.
    *   Explore sandboxing for Python DSP execution (e.g., using `firejail` on Linux).
*   **Developer Experience:**
    *   Create an `eeg-applet-cli` tool to scaffold new applets (directory structure, basic `manifest.json`, example UI/DSP files).
    *   Implement versioning for the `kioskApi` (e.g., `window.kioskApi.v1`, `window.kioskApi.v2`) to ensure backward compatibility.
*   **Build Process Refinement:**
    *   `scripts/build_dsp.py` should ideally generate a `Cargo.feature.toml` snippet.
    *   Maintain a one-to-one mapping: one DSP crate = one Cargo feature.
*   **Documentation:** This document serves as the primary architectural guide. A build-time sequence diagram (as above) is included. Runtime sequence diagrams remain valuable.

## 5. Strategic Decisions (V1 Focus)

*   **Rebuild vs. `dlopen` for new Rust DSPs:** For V1, the Cargo feature-based recompilation approach will be used. Dynamic loading (`dlopen`) can be explored as a V2 optimization if recompilation times become a significant bottleneck.
*   **Private Repositories:** Initially, applet installation will support public HTTPS Git URLs. Support for private repositories (e.g., via SSH deploy keys) can be a future enhancement.
*   **Error Surfacing:**
    *   Robust logging from the daemon and any Python runners.
    *   A console-like log panel in the Kiosk UI for user-facing errors.
    *   A dedicated `/logs` route or more advanced diagnostic tools can be added later.

## 6. Open Questions from Original Document (Addressed or Re-contextualized)

*   **Security:** Addressed with checksums, signature checks, sandboxing. Remains an ongoing concern.
*   **Python Dependencies:** Addressed with `dspDeps` and isolated environments.
*   **UI Bundling/Loading:** Kiosk will dynamically load applet UIs (e.g., Module Federation, dynamic `import()`).
*   **Error Handling & Debugging:** Addressed by V1 error surfacing plan.
*   **API Versioning:** Addressed with `kioskApi.vX`.
*   **Resource Management:** Important for multi-language runners (Python). Quotas/limits to be considered.
*   **Initial Applets:** Concepts like `gui_voltage_applet.rs`, `fft_spectrum_applet.rs` can be the first DSP crates and applets developed under this model.

This synthesized plan provides a solid foundation for developing the extensible applet architecture.