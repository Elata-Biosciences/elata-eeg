# EEG Applet Architecture: Synthesized Plan

This document outlines the refined architecture for the EEG "Applets" system, incorporating feedback for a modular, extensible, and developer-friendly approach. The core idea is to use selective compilation of DSP modules based on Cargo features, automated by a build script.

## 1. Core Architectural Principles

*   **Modularity:** DSP functionalities are encapsulated in separate Rust crates. Applet UIs are distinct components.
*   **Selective Compilation:** Only DSP modules actively used by installed applets are compiled into the main daemon, reducing build times and binary size.
*   **Automation:** A build script (`scripts/build_dsp.py`) handles the integration of DSP modules based on applet manifests.
*   **Developer Experience:** Streamlined processes for creating, installing, and managing applets, including CLI tooling and clear dependency management.

## 2. Key Components and Structure

### A. Project Structure (Conceptual)

```
/
├── Cargo.toml                # Workspace root (includes daemon and all DSP crates)
├── daemon/                   # Main backend service (Rust)
│   ├── src/
│   │   ├── applets/mod.rs    # Auto-generated by build_dsp.py
│   │   └── main.rs
│   └── Cargo.toml            # Defines features for each DSP crate
├── dsp/                      # Directory for all individual DSP Rust crates
│   ├── fft_spectrum/         # Example DSP crate
│   │   ├── src/lib.rs
│   │   └── Cargo.toml
│   └── band_power/           # Another example DSP crate
│       ├── src/lib.rs
│       └── Cargo.toml
├── applets/                  # Directory for all installed applets
│   ├── my_fft_applet/
│   │   ├── manifest.json     # { ..., "dsp": "fft_spectrum" }
│   │   ├── ui/               # React UI components
│   │   └── README.md
│   └── another_applet/
│       └── manifest.json     # { ..., "dsp": "band_power" }
├── kiosk/                    # React frontend application
└── scripts/
    └── build_dsp.py          # Python script for build automation
    └── eeg-applet-cli        # CLI tool for applet scaffolding
```

### B. `manifest.json` (Applet Definition)

Key fields relevant to this architecture:

```json
{
  "id": "unique-applet-id",
  "version": "1.0.0",
  "name": "FFT Spectrum Visualizer",
  "description": "Displays a real-time FFT spectrum.",
  // ... other fields like icon, UI entry points ...
  "dsp": "fft_spectrum", // or ["fft_spectrum", "another_dsp_if_needed"]
  "dspWebSocketPath": "/applet/fft_spectrum/data", // Example
  "requiredKioskApiVersion": "1.0.0" // For kioskApi.v1
}
```

### C. `daemon/Cargo.toml` (Relevant Sections)

```toml
[workspace]
members = [
  ".", # if daemon is the workspace root, or list daemon and dsp/* crates
  "../dsp/fft_spectrum",
  "../dsp/band_power",
  # ... other dsp crates
]

[features]
default = []
# Features will be dynamically populated or referenced from an included file
# Features will be dynamically populated by build_dsp.py.
# It will generate a main 'applets' feature that enables individual DSP features.
# e.g., applets = ["fft_spectrum", "band_power"]
fft_spectrum = ["elata_dsp_fft_spectrum"] # Assuming path or direct dependency
band_power = ["elata_dsp_band_power"]

[dependencies]
# Path dependencies to DSP crates, managed by build_dsp.py or manually
elata_dsp_fft_spectrum = { path = "../dsp/fft_spectrum", optional = true }
elata_dsp_band_power = { path = "../dsp/band_power", optional = true }

[profile.dev]
# Recommended for faster development rebuilds
incremental = true
```

### D. `daemon/src/applets/mod.rs` (Auto-Generated)

```rust
// This file is auto-generated by scripts/build_dsp.py

#[cfg(feature = "fft_spectrum")]
pub mod fft_spectrum {
    // Potentially use elata_dsp_fft_spectrum::* or similar
    // This part needs refinement based on how DSP crates expose their functionality
    // For example, if each DSP crate has a known entry point function or struct.
}

#[cfg(feature = "band_power")]
pub mod band_power {
    // pub use elata_dsp_band_power::*;
}

// ... other DSP modules based on active features
```
The exact content here will depend on how the daemon instantiates and calls the DSP logic from the compiled crates.

### E. `scripts/build_dsp.py` (Build Automation Script)

*   **Responsibilities:**
    1.  Scans all `applets/*/manifest.json` files to identify unique `dsp` modules required.
    2.  Generates/updates `daemon/src/applets/mod.rs` with `#[cfg(feature = "dsp_name")] pub mod dsp_name;` (or `use dsp_crate_name::*;`) for each required DSP.
    3.  Generates/updates the `[features]` section in `daemon/Cargo.toml` (or an included file) to define a main `applets` feature. This `applets` feature will conditionally enable individual features for each required DSP crate (e.g., `applets = ["fft_spectrum", "band_power"]`). It also ensures each DSP crate (e.g., `fft_spectrum`) is correctly defined as a feature that depends on its actual crate (e.g., `fft_spectrum = ["elata_dsp_fft_spectrum"]`).
    4.  Ensures all `dsp/*` Rust crates are correctly listed as optional dependencies in `daemon/Cargo.toml` and as members in the root `Cargo.toml`'s workspace definition.
    5.  (Future) Consider migrating this script's functionality to a Rust `build.rs` script within the `daemon` crate for tighter integration with Cargo's build process and potentially more robust cache invalidation.

## 3. Build and Compilation Flow

1.  Developer creates/installs an applet, specifying a DSP module in its `manifest.json`.
2.  Before building the daemon, `scripts/build_dsp.py` is run.
3.  The script updates `daemon/src/applets/mod.rs` and generates the necessary feature flags/config.
4.  `cargo build` (for the daemon) is executed with these features.
5.  Only the specified DSP crates (and their dependencies) are compiled into the daemon binary.

**Build Performance Note:** For development, using `sccache` is recommended to speed up recompilation times.

**Visualizing the Build Process:**

```mermaid
graph TD
    subgraph AppletDevelopment
        Dev[Applet Developer] -- Modifies/Creates --> Manifest(applets/*/manifest.json);
        Manifest -- Specifies Rust DSP crate --> DSPNeeded{{dsp: "cool_fft_crate"}};
    end

    subgraph BuildAutomationScript
        BuildScript[scripts/build_dsp.py] -- Scans all --> Manifest;
        BuildScript -- Generates --> ModRs(daemon/src/applets/mod.rs <br> `#[cfg(feature = "cool_fft_crate")] pub mod cool_fft_crate;`);
        BuildScript -- Generates/Updates --> FeaturesList(daemon/Cargo.toml features section <br> `applets = ["cool_fft_crate", ...]` <br> `cool_fft_crate = ["elata_dsp_cool_fft_crate"]`);
        BuildScript -- Ensures --> WorkspaceDeps(Root & Daemon Cargo.toml <br> lists dsp crates as members/deps);
    end

    subgraph DaemonCompilation
        DaemonCargo[daemon/Cargo.toml] -- Uses --> FeaturesList;
        Cargo[Cargo Build Process] -- Uses --> ModRs;
        Cargo -- Reads features from --> DaemonCargo;
        Cargo -- Conditionally compiles by enabling 'applets' feature --> DSPCrate("dsp/cool_fft_crate");
        DSPCrate --> DaemonBin(Compiled Daemon Binary);
    end

    AppletDevelopment --> BuildAutomationScript;
    BuildAutomationScript --> DaemonCompilation;
```

## 4. Key Enhancements Incorporated

*   **IPC Contract:** Clearly defined JSON schemas for messages and WebSocket topic structures are needed for stable communication between Kiosk UI, Applet UI, Daemon, and DSP runners. (To be detailed in a separate document or section).
*   **Security:**
    *   Implement checksum validation for downloaded applet packages (manifest, UI assets).
    *   Consider basic signature verification for applets from trusted sources.
    *   For Rust DSP crates, emphasize standard Rust ecosystem security practices (e.g., `cargo audit`, careful vetting of dependencies).
*   **Developer Experience:**
    *   Create an `eeg-applet-cli` tool to scaffold new applets. This tool will:
        *   Generate the necessary directory structure for an applet (including UI placeholders).
        *   Create a basic `manifest.json` file.
        *   Scaffold a new Rust DSP crate under the `dsp/` directory.
        *   Include a basic unit test template within the new DSP crate to verify its expected entry-point function signature, providing an early check against accidental breaking changes.
    *   Implement versioning for the `kioskApi` (e.g., `window.kioskApi.v1`, `window.kioskApi.v2`) to ensure backward compatibility.
*   **Build Process Refinement:**
    *   `scripts/build_dsp.py` manages the `daemon/Cargo.toml` features and dependencies related to DSP crates.
    *   The primary way to enable DSPs is through the top-level `applets` feature, which then enables individual DSP crate features.
*   **Documentation:** This document serves as the primary architectural guide. A build-time sequence diagram (as above) is included. Runtime sequence diagrams remain valuable.

## 5. Strategic Decisions (V1 Focus)

*   **Compilation Model for Rust DSPs (V1 - Static Compilation):** For V1, the Cargo feature-based recompilation approach will be used. New applets requiring new Rust DSP crates will necessitate a recompilation of the main daemon.
    *   **Rationale & Trade-offs:**
        *   **V1 Approach (Static Compilation):**
            *   *Pros:* Simpler initial build system integration with Cargo, results in a single daemon binary, potentially easier debugging of tightly integrated components.
            *   *Cons:* Can lead to longer "install" times for new applets (as it requires a full daemon recompilation), the daemon binary size may grow if many DSPs are included by default or become activated over time.
        *   **Future Consideration (Dynamic Loading - V2+):** Dynamic loading of DSP crates (e.g., via `cdylib` and `libloading`) is a planned V2 optimization.
            *   *Pros:* Would enable significantly faster applet installation/updates (no full daemon recompile), could lead to a smaller base daemon binary, and is a prerequisite for hot-swapping applets.
            *   *Cons:* Introduces complexity regarding ABI (Application Binary Interface) stability, Foreign Function Interface (FFI) management, dynamic library loading mechanisms, and potentially more complex security considerations.
*   **Applet Swapping (V1 - Restart Required):** Installing or uninstalling an applet in V1 will require a restart of the daemon. Hot-swapping (adding/removing applets without daemon restart) is not a V1 feature, aligning with the static compilation model.
*   **Private Repositories:** Initially, applet installation will support public HTTPS Git URLs. Support for private repositories (e.g., via SSH deploy keys) can be a future enhancement.
*   **Error Surfacing:**
    *   Robust logging from the daemon.
    *   A console-like log panel in the Kiosk UI for user-facing errors.
    *   A dedicated `/logs` route or more advanced diagnostic tools can be added later.

## 6. Open Questions from Original Document (Addressed or Re-contextualized)

*   **Security:** Addressed with checksums for applet packages and standard Rust security practices for DSP crates. Remains an ongoing concern.
*   **Python Dependencies:** Removed for V1 to simplify architecture.
*   **UI Bundling/Loading:** Kiosk will dynamically load applet UIs (e.g., Module Federation, dynamic `import()`).
*   **Error Handling & Debugging:** Addressed by V1 error surfacing plan.
*   **API Versioning:** Addressed with `kioskApi.vX`.
*   **Resource Management:** For V1, this primarily involves monitoring the main daemon process. As Rust DSPs are compiled in, they share the daemon's resources. Future considerations for dylibs would require more granular controls.
*   **ABI/Versioning for Rust DSPs:** While less critical for V1 due to static compilation, defining a clear C-FFI or using crates like `abi_stable` will be important if/when dynamic loading is introduced in future versions.
*   **Initial Applets:** Concepts like a simple voltage visualizer or an FFT spectrum display can be the first DSP crates and applets developed under this model.

This synthesized plan provides a solid foundation for developing the extensible applet architecture for V1, focusing on Rust-based DSPs integrated at compile time.
## 7. DSP Data Exposure, Routing, and API Aliasing

what if we want to expose the realtime dsp data over websocket or osc routes? how does the rust server know the route of the dsp module? is it like named after the folder its in? power_spectrum/ then that is the route root name?

then what if an external app is expecting the route names to be a particular name? is there an interposer that can rename it from /power_spectrum/8to13hz -> /alpha_waves ? how would this be done you think? the rust server would get teh data as message passing i think, but then to know how to expose it to a particular api.. or should the external applicaton know the api and it's on them?

ChatGPT said:
Making DSP streams discoverable (and rename‑able)

| Goal                                       | Minimal v1                                                                                                                               | Scalable v2                                                                                                                                                                                             |
| :----------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Tell the daemon where to publish           | Add an explicit field in `manifest.json` (you already hinted at `dspWebSocketPath`).<br>`"publish": { "ws": "/power_spectrum", "osc": "/power_spectrum" }` | Have each DSP crate implement a small trait, e.g.<br>`impl DspPublisher for BandPower { const DEFAULT_ROUTE: &'static str = "/band_power"; … }`<br>The build script gathers these constants into a registry (`lazy_static HashMap<&str, RouteMeta>`), so routes are typed, not string‑literals sprinkled around. |
| Expose multiple channels (e.g., 8–13 Hz, 13–30 Hz) | Publish a JSON object once per frame:<br>`{ "alpha": 12.4, "beta": 7.3 }`<br>The client can subscribe once and unpack keys.                 | Use hierarchical paths:<br>• WebSocket: `/band_power/alpha`, `/band_power/beta`.<br>• OSC: `/band_power/alpha` etc.<br>Route list is part of the registry above so the UI can auto‑discover.                               |
| Rename for a legacy client                 | Alias table in a simple `routes.yaml` loaded at boot:<br>```yaml<br>/band_power/alpha: /alpha_waves<br>/band_power/beta: /beta_waves<br>```<br>The daemon looks up `outgoing_path = alias.get(internal_path).unwrap_or(internal_path)` before it serialises. | Wrap the daemon with a thin proxy (nginx for WS, oscroute for OSC) so the core stays pure. Useful if you need per‑user remaps or TLS termination anyway.                                                  |
| Let an external app bind to custom names   | Ship a one‑liner REPL / CLI:<br>`eeg route add /band_power/alpha /alpha_waves`.<br>It just edits `routes.yaml` and sends a SIGHUP to reload. | Expose a REST or gRPC endpoint: `POST /api/routes {from: “…”, to: “…”}`—keeps state out of files, plays nicely with a UI settings panel.                                                                     |

How the data flows

```mermaid
graph LR
    subgraph DSP crate
        A(BandPower::tick()) -->|returns f32 values| B
    end
    B -->|send on mpsc| C[Router task\n(internal paths)]
    C -->|alias lookup| D[WebSocket/OSC\nsender]
    D -->|/alpha_waves 12.4| Client
```
Router is just an async task that owns a `HashMap<Route, Vec<Subscriber>>`.

Aliasing happens once when the message enters the network layer, so internal code never sees “pretty” names.

TL;DR

*   Declare the canonical route in each applet (either in `manifest.json` or via a Rust trait).
*   Keep a tiny alias map (file or API). The daemon rewrites paths before emit.
*   External tools can either:
    *   accept your canonical API, or
    *   install aliases without touching any DSP code.

That keeps internal names stable, lets legacy clients pick whatever routes they need, and avoids hard‑coding folder names or magic strings throughout the codebase.