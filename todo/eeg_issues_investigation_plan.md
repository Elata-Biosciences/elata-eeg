# EEG Recording and FFT Timing Investigation Plan

This document outlines the investigation into two issues:
1.  EEG recording only saving channel 0 (ch0) to CSV, despite the UI displaying two active channels.
2.  Clarification on when the FFT DSP pipeline is calculated.

## Issue 1: EEG Recording - Only Channel 0 Saved

**Symptom:** The CSV output of EEG recordings contains data only for `ch0`. However, the Kiosk UI (both time-amplitude signal plot and FFT plot) displays two distinct, active channels.

**Investigation Summary:**

The investigation involved tracing the channel configuration and data flow from the Kiosk UI, through the `daemon` process, down to the `driver` (`Ads1299Driver`), and back to the `daemon`'s `CsvRecorder`.

1.  **Kiosk UI (`EegMonitor.tsx`, `EegConfig.tsx`):**
    *   The UI correctly forms a `ConfigMessage` with the selected number of channels (e.g., `channels: [0, 1]` for two channels).
    *   This message is sent to the `daemon`'s `/config` WebSocket endpoint.
    *   The UI also correctly subscribes to and updates its global `AdcConfig` state when the `daemon` broadcasts an applied configuration.

2.  **Daemon (`server.rs`, `main.rs`):**
    *   `server.rs` (`handle_config_websocket`) receives the `ConfigMessage`, parses it, and if valid, proposes an updated `AdcConfig` (with the correct channels) to `main.rs`.
    *   `main.rs` receives this proposed `AdcConfig`. If different from the current active config and not recording, it:
        *   Stops the current `EegSystem`.
        *   Creates and starts a *new* `EegSystem` instance, passing the new `AdcConfig` (with the correct channels from the UI).
        *   Updates its shared `Arc<Mutex<AdcConfig>>`.
        *   Broadcasts the newly applied `AdcConfig` (which the Kiosk UI receives).
        *   Calls `csv_recorder.update_config()` with the new `AdcConfig`.

3.  **Driver (`EegSystem`, `Ads1299Driver`, `acquisition.rs`, `helpers.rs`):**
    *   `EegSystem::new()` receives the `AdcConfig` (e.g., with `channels: [0, 1]`) from `daemon/main.rs`.
    *   It calls `create_driver()`, which instantiates `Ads1299Driver` with this `AdcConfig`.
    *   `Ads1299Driver::new()` stores this `AdcConfig`.
    *   `Ads1299Driver::initialize_chip()` (called during `start_acquisition`) correctly uses `config.channels` from the stored `AdcConfig` to:
        *   Turn OFF all hardware channels.
        *   Turn ON only the specific channels listed in `config.channels` (e.g., channel 0 and channel 1).
    *   `acquisition.rs` uses `num_channels = config.channels.len()` to determine how many channels to read data for.
    *   `helpers.rs::read_data_from_spi()` is called with the correct `num_channels` and is designed to read and parse data for all specified active channels from the hardware.
    *   The `ProcessedData` generated by the driver should therefore contain data for all configured active channels.

4.  **Daemon (`driver_handler.rs` - `CsvRecorder`):**
    *   `process_eeg_data` receives `ProcessedData` from the driver. If the UI shows 2 active channels, this `ProcessedData` should contain 2 channels of data (`data.voltage_samples.len() == 2`).
    *   This `ProcessedData` is used to generate `EegBatchData` for UI broadcast (explaining why UI shows 2 channels).
    *   The *same* `ProcessedData` instance is passed to `csv_recorder.write_data()`.
    *   `CsvRecorder::start_recording()` writes CSV headers based on its `current_adc_config.channels`.
    *   `CsvRecorder::write_data()` iterates based on its `current_adc_config.channels`. For each configured channel, it attempts to get data from the incoming `ProcessedData.voltage_samples[idx]`, but only if `idx < data.voltage_samples.len()`. If `idx >= data.voltage_samples.len()`, it pads with zeros.

**Hypothesis for Recording Issue:**

Despite the code appearing logically sound for multi-channel handling end-to-end, the symptom (CSV only has `ch0` data, and *nothing* for `ch1`, not even zeros) strongly suggests that when `CsvRecorder::write_data` is executed, its `self.current_adc_config.channels` list effectively contains only one channel (e.g., `[0]`).

If `self.current_adc_config.channels` was `[0, 1]` and `data.voltage_samples.len()` was `1` (meaning driver only sent 1 channel), the CSV would show `ch0` data and `ch1` as zeros. This is not the reported symptom.

Therefore, the most likely scenario is:
*   The `ProcessedData` arriving at `CsvRecorder::write_data` *does* contain two channels of data (as evidenced by the UI correctly displaying two active channels).
*   However, the `CsvRecorder`'s internal state `self.current_adc_config.channels` at the moment `write_data` is called only contains one channel (e.g., `vec![0]`).
*   This causes the loop `for (idx, &_channel_idx) in self.current_adc_config.channels.iter().enumerate()` within `write_data` to iterate only once (for channel 0), thus only writing channel 0's data to the CSV record.

This points to a potential issue where the `csv_recorder.update_config()` call in `daemon/main.rs` is either not happening as expected before a recording starts/continues, or the `new_config_from_channel` passed to it does not actually contain the multiple channels requested by the UI at the critical moment. However, static analysis of `daemon/main.rs` and `daemon/server.rs` suggests `new_config_from_channel` *should* be correct.

**Next Steps for Recording Issue (in Code Mode):**

1.  **Add Detailed Logging:**
    *   In `daemon/src/main.rs`:
        *   Log the `new_config_from_channel` just before calling `csv_recorder.update_config()`.
        *   Log the state of `csv_recorder.current_adc_config.channels` immediately after the update.
    *   In `daemon/src/driver_handler.rs` (`CsvRecorder::write_data`):
        *   Log `self.current_adc_config.channels` at the beginning of the function.
        *   Log `data.voltage_samples.len()` and the length of each inner vector in `data.voltage_samples`.
        *   Log the content of `record` just before `writer.write_record(&record)`.
    *   In `daemon/src/driver_handler.rs` (`CsvRecorder::start_recording`):
        *   Log `self.current_adc_config.channels` when generating headers.
2.  **Verify `config.json`:** Confirmed `driver_type` is `Ads1299`.
3.  **Analyze Logs:** Run the system, attempt to record with 2 channels, and analyze the generated logs to pinpoint the state of `CsvRecorder`'s configuration versus the incoming `ProcessedData`.

## Issue 2: FFT Calculation Timing

**Symptom:** User wants to know when the FFT is being calculated in the DSP pipeline, especially in relation to the time-amplitude plot and the FFT graph display.

**Findings (from `dsp/brain_waves_fft/src/lib.rs`):**

*   The FFT calculation is handled by the `dsp_brain_waves_fft` Rust crate.
*   This crate exposes a WebSocket endpoint: `/applet/brain_waves/data`.
*   When the "Brain Waves" applet in the Kiosk UI is active, it connects to this WebSocket.
*   The `handle_brain_waves_fft_websocket` function in `dsp/brain_waves_fft/src/lib.rs` subscribes to the `EegBatchData` broadcast stream from `daemon/src/driver_handler.rs`. This is the same data stream that feeds the main time-amplitude signal plot in the Kiosk UI.
*   FFT is calculated using a **sliding window** approach:
    *   Data for each channel is buffered internally within `handle_brain_waves_fft_websocket`.
    *   Constants `FFT_WINDOW_DURATION_SECONDS` (currently 2.0 seconds) and `FFT_WINDOW_SLIDE_SECONDS` (currently 1.0 second) define the windowing parameters.
    *   When `FFT_WINDOW_DURATION_SECONDS` worth of data accumulates for a channel, the `process_eeg_data` function (also in `dsp/brain_waves_fft/src/lib.rs`) is called to compute the FFT (power spectrum and frequency bins) for that window of data.
    *   The window then "slides" forward by `FFT_WINDOW_SLIDE_SECONDS` (meaning `FFT_WINDOW_SLIDE_SECONDS` worth of old data is removed from the buffer), and the process repeats as new data arrives.
*   The results (`ChannelFftResult`) are packaged into a `BrainWavesAppletResponse` and sent as a JSON message over the WebSocket to the connected "Brain Waves" applet client.

**Conclusion on FFT Timing:**

The FFT calculation is **continuously running in the background** as long as the "Brain Waves" applet is active and its WebSocket connection to `/applet/brain_waves/data` is maintained. It processes incoming `EegBatchData` using the sliding window mechanism described above. This occurs independently of whether the user is currently viewing the raw signal plot or the FFT graph display within the Kiosk UI. If the applet is running, the FFT DSP is processing.

---

This plan should provide a clear path to understanding and resolving the recording issue and clarifies the FFT processing.