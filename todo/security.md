Consider additional security measures for a production system.

# Websocket
Understood. Prioritizing security and replacing the existing WS with WSS on the same port is a solid approach. Making certificate paths configurable offers good flexibility.

Here's a detailed plan to implement WSS:

Plan to Implement WSS (WebSocket Secure)
Goal: Secure WebSocket communications by replacing ws:// with wss:// using TLS encryption.

Key Decisions:

Certificate Source: Self-signed certificates generated by kiosk/generate-certs.sh (localhost-cert.pem and localhost-key.pem).
Certificate Access for Daemon: Certificate paths will be made configurable in config.json. For development, we'll assume these certificates are accessible relative to the daemon's execution path or copied to a known location.
Port: WSS will replace WS on the current port 8080.
Scope:
Server-side: Modify the Rust warp server in the daemon to enable TLS.
Client-side: Update all WebSocket connection URLs in the kiosk application.
Phase 1: Server-Side Modifications (Rust Daemon)
Update config.json and daemon/src/config.rs:

Add new fields to config.json for TLS certificate and key paths.
Example: "tls_cert_path": "../kiosk/localhost-cert.pem"
Example: "tls_key_path": "../kiosk/localhost-key.pem" (Note: These default paths assume the daemon is run from a location like daemon/target/debug/ or similar, making ../kiosk/ a valid relative path. This might need adjustment based on the actual execution environment or a build step to copy certs.)
Update the DaemonConfig struct in daemon/src/config.rs to include these new fields.
Update the load_config() function in daemon/src/config.rs to load these new paths.
Modify daemon/src/main.rs:

Retrieve the tls_cert_path and tls_key_path from the loaded daemon_config.
Modify the warp::serve call to enable TLS:
// Existing line:
// let server_handle = tokio::spawn(warp::serve(ws_routes).run(([0, 0, 0, 0], 8080)));

// New lines:
let cert_path = daemon_config.tls_cert_path; // Assuming these fields are added to DaemonConfig
let key_path = daemon_config.tls_key_path;

println!("Attempting to start WSS server on 0.0.0.0:8080");
println!("Using certificate: {}", cert_path);
println!("Using key: {}", key_path);

let server_handle = tokio::spawn(
    warp::serve(ws_routes)
        .tls()
        .cert_path(cert_path) // Use configured path
        .key_path(key_path)   // Use configured path
        .run(([0, 0, 0, 0], 8080)), // Keep port 8080 for WSS
);

rust


Update the informational println! statements that show the WebSocket URLs to use wss:// instead of ws:// and reflect the port:
// println!("- ws://0.0.0.0:8080/eeg ...");
// Change to:
println!("- wss://0.0.0.0:8080/eeg (EEG data) - accessible via this machine's IP address");
println!("- wss://0.0.0.0:8080/config (Configuration) - accessible via this machine's IP address");
println!("- wss://0.0.0.0:8080/command (Recording control) - accessible via this machine's IP address");

rust


Phase 2: Client-Side Modifications (Kiosk Application)
Identify all WebSocket connection points:
Based on the initial search, these files in the kiosk/ directory instantiate WebSockets:

kiosk/main.ts
kiosk/src/components/EegChannelConfig.tsx
kiosk/src/components/EegConfig.tsx
kiosk/src/components/EegDataHandler.tsx
kiosk/src/components/EegMonitor.tsx
kiosk/src/components/EegStatusBar.tsx
kiosk/src/context/CommandWebSocketContext.tsx
kiosk/websocket-test.html
Update WebSocket URLs:

In each identified file, change the WebSocket URL scheme from ws:// to wss://.

Ensure the port remains 8080 (or whatever port is configured if it changes, but the plan is to keep it 8080).

Example:
const ws = new WebSocket('ws://localhost:8080');
becomes
const ws = new WebSocket('wss://localhost:8080');

And for dynamic host:
const ws = new WebSocket(\ws://${wsHost}:8080/eeg`);becomesconst ws = new WebSocket(`wss://${wsHost}:8080/eeg`);`

Phase 3: Certificate Generation and Management
Ensure Certificates are Generated:

Run the kiosk/generate-certs.sh script to create localhost-key.pem and localhost-cert.pem in the kiosk/ directory.
This step is crucial before starting the daemon.
Ensure Daemon Can Access Certificates:

Verify that the paths configured in config.json (and used by the daemon) correctly point to the generated certificate files relative to where the daemon executable will be run.
If running the daemon from daemon/target/debug/ (a common scenario for cargo run), then relative paths like ../kiosk/localhost-cert.pem should work, assuming the kiosk and daemon directories are siblings.
Alternatively, as part of a build/run script, these certificates could be copied to a location the daemon expects (e.g., a daemon/certs/ directory, and then config.json would point to certs/localhost-cert.pem). For simplicity with the current setup, relative paths are assumed first.
Phase 4: Testing
Generate Certificates: Run kiosk/generate-certs.sh.
Rebuild and Run Daemon:
cd daemon
cargo build (or cargo run)
Observe daemon logs to ensure it starts WSS on port 8080 and correctly loads the certificates.
Test Kiosk Application:
Run the Kiosk application (npm run dev in the kiosk directory, or however it's usually run).
Open the browser's developer console.
Important: Since these are self-signed certificates, the browser will show a security warning. You will need to accept this warning (e.g., "Proceed to localhost (unsafe)") to allow the WSS connection.
Verify that all WebSocket connections are established successfully using wss:// and that data flows as expected (EEG data, config updates, commands).
Check for any console errors related to WebSocket connections.
